{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unofficial companion site of TCP/IP Illustrated, Volume 2: The Implementation TCP/IP Illustrated, Volume 2: The Implementation is written by Gary R. Wright and W. Richard Stevens, published in 1995. Official book page This book presents the TCP/IP stack of 4.4BSD-Lite. This site is based on a slightly newer version: 4.4BSD-Lite2. Run TCP/IP stack of 4.4BSD-Lite2 On Linux, $ git clone https://github.com/chenshuo/4.4BSD-Lite2.git $ cd 4.4BSD-Lite2 $ make This build three executables: objs/test_init TCP three-way handshake, you can step through code with GDB , or check the calltree objs/test_pigeon ICMP echo request/response objs/test_tun Connect to host with TAP/TUN device Calltree of TCP three-way handshaking calltree $ objs/test_init $ tcpdump -r init.pcap reading from file init.pcap, link-type RAW (Raw IP) 07:02:11.718036 IP localhost > localhost: ICMP echo request, id 4995, seq 1, length 64 07:02:11.718039 IP localhost > localhost: ICMP echo reply, id 4995, seq 1, length 64 07:02:11.718135 IP localhost.1024 > localhost.1234: Flags [S], seq 1804289383, win 8192, options [mss 1496], length 0 07:02:11.718142 IP localhost.1234 > localhost.1024: Flags [S.], seq 1804333538, ack 1804289384, win 8976, options [mss 1496], length 0 07:02:11.718144 IP localhost.1024 > localhost.1234: Flags [.], ack 1, win 8976, length 0 07:02:11.718203 IP localhost.1024 > localhost.1234: Flags [.], seq 1:1497, ack 1, win 8976, length 1496 07:02:11.718206 IP localhost.1234 > localhost.1024: Flags [.], ack 1497, win 7480, length 0 07:02:11.718213 IP localhost.1024 > localhost.1234: Flags [.], seq 1497:2993, ack 1, win 8976, length 1496 07:02:11.718215 IP localhost.1024 > localhost.1234: Flags [.], seq 2993:4489, ack 1, win 8976, length 1496 07:02:11.718233 IP localhost.1234 > localhost.1024: Flags [.], ack 4489, win 4488, length 0 07:02:11.718241 IP localhost.1024 > localhost.1234: Flags [.], seq 4489:5985, ack 1, win 8976, length 1496 07:02:11.718242 IP localhost.1024 > localhost.1234: Flags [.], seq 5985:7481, ack 1, win 8976, length 1496 07:02:11.718251 IP localhost.1024 > localhost.1234: Flags [P.], seq 7481:8977, ack 1, win 8976, length 1496 07:02:11.718254 IP localhost.1234 > localhost.1024: Flags [.], ack 8977, win 0, length 0 07:02:11.718290 IP localhost.1234 > localhost.1024: Flags [.], ack 8977, win 7000, length 0 07:02:11.718309 IP localhost.1024 > localhost.1234: Flags [F.], seq 8977, ack 1, win 8976, length 0 07:02:11.718310 IP localhost.1234 > localhost.1024: Flags [.], ack 8978, win 7000, length 0 07:02:11.718326 IP localhost.1234 > localhost.1024: Flags [F.], seq 1, ack 8978, win 8976, length 0 07:02:11.718328 IP localhost.1024 > localhost.1234: Flags [.], ack 2, win 8976, length 0 GDB session of TCP three-way handshaking Source of this site is on GitHub","title":"Home"},{"location":"#run-tcpip-stack-of-44bsd-lite2","text":"On Linux, $ git clone https://github.com/chenshuo/4.4BSD-Lite2.git $ cd 4.4BSD-Lite2 $ make This build three executables: objs/test_init TCP three-way handshake, you can step through code with GDB , or check the calltree objs/test_pigeon ICMP echo request/response objs/test_tun Connect to host with TAP/TUN device","title":"Run TCP/IP stack of 4.4BSD-Lite2"},{"location":"#calltree-of-tcp-three-way-handshaking","text":"calltree $ objs/test_init $ tcpdump -r init.pcap reading from file init.pcap, link-type RAW (Raw IP) 07:02:11.718036 IP localhost > localhost: ICMP echo request, id 4995, seq 1, length 64 07:02:11.718039 IP localhost > localhost: ICMP echo reply, id 4995, seq 1, length 64 07:02:11.718135 IP localhost.1024 > localhost.1234: Flags [S], seq 1804289383, win 8192, options [mss 1496], length 0 07:02:11.718142 IP localhost.1234 > localhost.1024: Flags [S.], seq 1804333538, ack 1804289384, win 8976, options [mss 1496], length 0 07:02:11.718144 IP localhost.1024 > localhost.1234: Flags [.], ack 1, win 8976, length 0 07:02:11.718203 IP localhost.1024 > localhost.1234: Flags [.], seq 1:1497, ack 1, win 8976, length 1496 07:02:11.718206 IP localhost.1234 > localhost.1024: Flags [.], ack 1497, win 7480, length 0 07:02:11.718213 IP localhost.1024 > localhost.1234: Flags [.], seq 1497:2993, ack 1, win 8976, length 1496 07:02:11.718215 IP localhost.1024 > localhost.1234: Flags [.], seq 2993:4489, ack 1, win 8976, length 1496 07:02:11.718233 IP localhost.1234 > localhost.1024: Flags [.], ack 4489, win 4488, length 0 07:02:11.718241 IP localhost.1024 > localhost.1234: Flags [.], seq 4489:5985, ack 1, win 8976, length 1496 07:02:11.718242 IP localhost.1024 > localhost.1234: Flags [.], seq 5985:7481, ack 1, win 8976, length 1496 07:02:11.718251 IP localhost.1024 > localhost.1234: Flags [P.], seq 7481:8977, ack 1, win 8976, length 1496 07:02:11.718254 IP localhost.1234 > localhost.1024: Flags [.], ack 8977, win 0, length 0 07:02:11.718290 IP localhost.1234 > localhost.1024: Flags [.], ack 8977, win 7000, length 0 07:02:11.718309 IP localhost.1024 > localhost.1234: Flags [F.], seq 8977, ack 1, win 8976, length 0 07:02:11.718310 IP localhost.1234 > localhost.1024: Flags [.], ack 8978, win 7000, length 0 07:02:11.718326 IP localhost.1234 > localhost.1024: Flags [F.], seq 1, ack 8978, win 8976, length 0 07:02:11.718328 IP localhost.1024 > localhost.1234: Flags [.], ack 2, win 8976, length 0","title":"Calltree of TCP three-way handshaking"},{"location":"#gdb-session-of-tcp-three-way-handshaking","text":"Source of this site is on GitHub","title":"GDB session of TCP three-way handshaking"},{"location":"init/","text":"tcp_init","title":"Initialization"},{"location":"init/#tcp_init","text":"","title":"tcp_init"},{"location":"syscall/","text":"Ch. 15 Sockets API We directly programming with struct socket , bypassing the proc and file struct s. To step through the code, run gdb objs/test_init , then set break points on socreate , sobind , etc. socket() int socket(int domain, int type, int protocol); int sockfd = socket(AF_INET, SOCK_STREAM, 0); socket(AF_INET, SOCK_STREAM, 0) -> syscall -> socket -> socreate(AF_INET, aso = &so, SOCK_STREAM, 0) struct protosw *prp = pffindtype(AF_INET, SOCK_STREAM); struct socket *so = malloc(); prp->pr_usrreq(so, PRU_ATTACH, ...) -> tcp_usrreq(so, PRU_ATTACH, ...) -> tcp_attach(so) -> soreserve(so, tcp_sendspace=8192, tcp_recvspace=8192) -> sbreserve(&so->so_snd, tcp_sendspace=8192) -> sbreserve(&so->so_rcv, tcp_recvspace=8192) -> in_pcballoc(so, &tcb) -> struct inpcb *inp = sotoinpcb(so) -> struct tcpcb *tp = tcp_newtcpcb(inp) -> tp->t_state = TCPS_CLOSED; *aso = so connect() connect() // connect to 127.0.0.1:1234 -> syscall -> connect -> soconnect(struct socket *so, struct mbuf *nam) so->so_proto->pr_usrreq(so, PRU_CONNECT, NULL, nam, NULL) -> tcp_usrreq(so, PRU_CONNECT, ...) if (inp->inp_lport == 0) in_pcbbind(inp, NULL) // common unless bind() already -> in_pcbconnect(inp, nam) -> rtalloc tp->t_template = tcp_template(tp) soisconnecting(so) tp->t_state = TCPS_SYN_SENT; -> tcp_sendseqinit(tp) -> tcp_output(tp) // send SYN -> in_cksum() -> ip_output() -> in_cksum() -> ifp->if_output() -> looutput() bind() bind() // bind on 0.0.0.0:1234 -> syscall -> bind -> sobind(struct socket *so, struct mbuf *nam) so->so_proto->pr_usrreq(so, PRU_BIND, NULL, nam, NULL) -> tcp_usrreq(so, PRU_BIND, ...) -> in_pcbbind(inp, nam) listen() listen() // backlog = 5 -> syscall -> listen -> solisten(struct socket *so, int backlog) so->so_proto->pr_usrreq)(so, PRU_LISTEN, ...) -> tcp_usrreq(so, PRU_LISTEN, ...) if (inp->inp_lport == 0) in_pcbbind(inp, NULL) // uncommon, because bind() already tp->t_state = TCPS_LISTEN; so->so_options |= SO_ACCEPTCONN so->so_qlimit = min(backlog, SOMAXCONN) accept() close()","title":"System calls"},{"location":"syscall/#ch-15-sockets-api","text":"We directly programming with struct socket , bypassing the proc and file struct s. To step through the code, run gdb objs/test_init , then set break points on socreate , sobind , etc.","title":"Ch. 15 Sockets API"},{"location":"syscall/#socket","text":"int socket(int domain, int type, int protocol); int sockfd = socket(AF_INET, SOCK_STREAM, 0); socket(AF_INET, SOCK_STREAM, 0) -> syscall -> socket -> socreate(AF_INET, aso = &so, SOCK_STREAM, 0) struct protosw *prp = pffindtype(AF_INET, SOCK_STREAM); struct socket *so = malloc(); prp->pr_usrreq(so, PRU_ATTACH, ...) -> tcp_usrreq(so, PRU_ATTACH, ...) -> tcp_attach(so) -> soreserve(so, tcp_sendspace=8192, tcp_recvspace=8192) -> sbreserve(&so->so_snd, tcp_sendspace=8192) -> sbreserve(&so->so_rcv, tcp_recvspace=8192) -> in_pcballoc(so, &tcb) -> struct inpcb *inp = sotoinpcb(so) -> struct tcpcb *tp = tcp_newtcpcb(inp) -> tp->t_state = TCPS_CLOSED; *aso = so","title":"socket()"},{"location":"syscall/#connect","text":"connect() // connect to 127.0.0.1:1234 -> syscall -> connect -> soconnect(struct socket *so, struct mbuf *nam) so->so_proto->pr_usrreq(so, PRU_CONNECT, NULL, nam, NULL) -> tcp_usrreq(so, PRU_CONNECT, ...) if (inp->inp_lport == 0) in_pcbbind(inp, NULL) // common unless bind() already -> in_pcbconnect(inp, nam) -> rtalloc tp->t_template = tcp_template(tp) soisconnecting(so) tp->t_state = TCPS_SYN_SENT; -> tcp_sendseqinit(tp) -> tcp_output(tp) // send SYN -> in_cksum() -> ip_output() -> in_cksum() -> ifp->if_output() -> looutput()","title":"connect()"},{"location":"syscall/#bind","text":"bind() // bind on 0.0.0.0:1234 -> syscall -> bind -> sobind(struct socket *so, struct mbuf *nam) so->so_proto->pr_usrreq(so, PRU_BIND, NULL, nam, NULL) -> tcp_usrreq(so, PRU_BIND, ...) -> in_pcbbind(inp, nam)","title":"bind()"},{"location":"syscall/#listen","text":"listen() // backlog = 5 -> syscall -> listen -> solisten(struct socket *so, int backlog) so->so_proto->pr_usrreq)(so, PRU_LISTEN, ...) -> tcp_usrreq(so, PRU_LISTEN, ...) if (inp->inp_lport == 0) in_pcbbind(inp, NULL) // uncommon, because bind() already tp->t_state = TCPS_LISTEN; so->so_options |= SO_ACCEPTCONN so->so_qlimit = min(backlog, SOMAXCONN)","title":"listen()"},{"location":"syscall/#accept","text":"","title":"accept()"},{"location":"syscall/#close","text":"","title":"close()"},{"location":"tcp/","text":"TCP scenarios Three-way handshaking. Active open (client connect s) Step 1: connect() sends SYN , see here Step 2: receives SYN+ACK from server, sends ACK . Passive open (server accept s) First, call bind() and listen() to setup the server. Step 1: Receives SYN from client, sends SYN+ACK Step 2: Receives ACK from client Then we can accept() .","title":"TCP"},{"location":"tcp/#tcp-scenarios","text":"Three-way handshaking.","title":"TCP scenarios"},{"location":"tcp/#active-open-client-connects","text":"Step 1: connect() sends SYN , see here Step 2: receives SYN+ACK from server, sends ACK .","title":"Active open (client connects)"},{"location":"tcp/#passive-open-server-accepts","text":"First, call bind() and listen() to setup the server. Step 1: Receives SYN from client, sends SYN+ACK Step 2: Receives ACK from client Then we can accept() .","title":"Passive open (server accepts)"}]}